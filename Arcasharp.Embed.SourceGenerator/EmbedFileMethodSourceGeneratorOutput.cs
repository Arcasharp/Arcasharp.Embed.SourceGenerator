using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Arcasharp.Embed.SourceGenerator;

internal sealed class EmbedFileMethodSourceGeneratorOutput
{
    private readonly EmbeddedFile _file;

    public EmbedFileMethodSourceGeneratorOutput(EmbeddedFile file)
    {
        _file = file;
    }

    public string GenerateSource()
    {
        string placeholder = "/* START-PLACEHOLDER */ new byte[0] /* END-PLACEHOLDER */";
        string codeWithPlaceholder = 
            $$"""
            // <auto-generated>
            #nullable enable

            using global::System.Runtime.CompilerServices;
            
            {{GetNamespaceBeginBlock(_file)}}
            {{GetClassBeginBlock(_file)}}
                
                [CompilerGenerated]
                private static {{GetMethodTypeSource(_file.MethodType!.Value)}} _{{_file.MethodName}} = {{placeholder}};
              
                [CompilerGenerated]
                {{_file.MethodVisibility}} static partial {{GetMethodTypeSource(_file.MethodType!.Value)}} {{_file.MethodName}}() 
                {
                    return _{{_file.MethodName}};
                }
                
            {{GetClassEndBlock(_file)}}
            {{GetNamespaceEndBlock(_file)}}
            """;
        
        // Normalizing the whitespace can take a huge amount of time for large files, we normalize the source without the file content
        string formattedCodeWithPlaceholder = FormatCSharpCode(codeWithPlaceholder);
        string content = GetContent(_file);
        string sourceCode = formattedCodeWithPlaceholder.Replace(placeholder, content);
        return sourceCode;
    }

    private static string GetContent(EmbeddedFile file)
    {
        return file.MethodType switch
        {
            MethodType.ByteArray => GetContentAsByteArrayInitializer(file),
            MethodType.String => GetContentAsStringInitializer(file),
            _ => throw new InvalidOperationException($"Unknown method type: {file.MethodType}")
        };
    }

    private static string GetMethodTypeSource(MethodType fileMethodType)
    {
        return fileMethodType switch
        {
            MethodType.ByteArray => "byte[]",
            MethodType.String => "string",
            _ => throw new ArgumentOutOfRangeException(nameof(fileMethodType), fileMethodType, null)
        };
    }

    private static string FormatCSharpCode(string codeWithPlaceholder)
    {
        return CSharpSyntaxTree
            .ParseText(codeWithPlaceholder)
            .GetRoot()
            .NormalizeWhitespace()
            .ToFullString();
    }

    private static string GetNamespaceBeginBlock(EmbeddedFile file)
    {
        return file.Namespace == string.Empty ? string.Empty : $"namespace {file.Namespace} {{";
    }

    private static string GetNamespaceEndBlock(EmbeddedFile file)
    {
        return file.Namespace == string.Empty ? string.Empty : "}";
    }

    private static string GetClassBeginBlock(EmbeddedFile file)
    {
        StringBuilder builder = new();
        List<ClassDefinition> classes = new();
        ClassDefinition? currentClass = file.Class;
        while (currentClass is not null)
        {
            classes.Add(currentClass);
            currentClass = currentClass.Parent;
        }

        classes.Reverse();

        foreach (ClassDefinition? @class in classes)
        {
            builder.AppendLine($"{@class.Visibility} static partial class {@class.Name}");
            builder.AppendLine("{");
        }

        return builder.ToString();
    }

    private static string GetClassEndBlock(EmbeddedFile file)
    {
        StringBuilder builder = new();
        List<ClassDefinition> classes = new();
        ClassDefinition? currentClass = file.Class;
        while (currentClass is not null)
        {
            classes.Add(currentClass);
            currentClass = currentClass.Parent;
        }

        int classCount = classes.Count;
        for (int i = 0; i < classCount; i++)
        {
            builder.AppendLine("}");
        }

        return builder.ToString();
    }

    private static string GetContentAsByteArrayInitializer(EmbeddedFile file)
    {
        StringBuilder builder = new();
        builder.Append("new byte[] { ");
        byte[] content = File.ReadAllBytes(file.FullFilePath);
        foreach (byte b in content)
        {
            builder.AppendFormat("0x{0:X2}, ", b);
        }

        builder.Remove(builder.Length - 2, 2);
        builder.Append(" }");
        return builder.ToString();
    }

    private static string GetContentAsStringInitializer(EmbeddedFile file)
    {
        string content = File.ReadAllText(file.FullFilePath);
        return Sanitize(content);
    }

    private static string Sanitize(string str)
    {
        return SymbolDisplay.FormatLiteral(str, true);   
    }
}